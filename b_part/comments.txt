Draft AI


- search strategy
- evaluation function
- creative techniques
	- machine learning
	- search strategy optimisation
	- specialised data structures
	- other optimisation
	- search algorithm not discussed in lectures


Additional Stuff
- alternative Player class
- modified referee
- additional programs to test player strategy
- programs to create training data for ML
- programs for other purpose not directly related to Player class


Notes about assessment criteria:
	Total: 22 marks
		- 4 marks
			- quality of code
			- OOP
			- readability
			- comments & docstrings
		- 4 marks
			- correctness of program
			- no runtime errors
			- no illegal moves
			- no violation of memory constraints (100MB entire game)
			- no violation of time constraints (60s entire game)
		- 7 marks
			- performance of our Player againts smart AI
		- 7 marks
			- pro-active points
			- techniques used not taught in lectures


## What have we done so far?
**well first of all, TianLei the "wizard" here implemented and released WYB-online (Human vs Human) in a matter of days [definitely deserve some credit for pro-activeness]**

- placing phase
	1. placing pieces to kill (currently not explicit, just done by using miniMax)
	2. placing pieces at strategic positions (eg. in the middle area first because board will shrink)
- moving phase
	3. alpha-beta minimax with depth limiting 
	4. reducing search space
	5. detecting mirroring & symmetry

	6. using byte arrays (eg. ad arrays.arrays)
	7. optimising efficiency of search (eg. by limiting search space to shrinked board size during placing phase)
	8. only storing deltas/changes (eg. and applying them when need to know current state of board)
	9. use transposition tables/storing of seen states so that dont need to re-search branch (eg. used in miniMax get_min & get_max)

## Going to do
- placing phase
	[currently nothing to do]
- moving phase
	10. monte carlo search (attempted, currently WIP to make better)
	11. TDLeaf search
	12. negamax (basically combining max and min function), negascout/principle variation search, SSS* (sorting game tree for faster discovery)
	13. tweaking utility/heuristic function (WIP)
	14. 	- having weightage of cells at different position
	15. 	- keeping a square or rectangle formation in centre and not moving them if possible (only move if no other pieces can be moved and cant forfeit turn, move piece that is not accessible by other piece)
	16. changing the MAX_DEPTH when board shrinks (change is twice, once when first shrink and another when second shrink)
	17. having a sustained
		STATE = {
			strong_hand 	# just need to keep moving piece that is not accessible until end of game
			offensive		# change heuristic to be aggresive
		}
- before submission clean up
	i.   no violation of memory constraints (100MB entire game)
	ii.  no violation of time constraints (120s entire game) [or 60s -@TODO email Matt]
	iii. correctness of program (unit test)
			- no runtime errors
			- no illegal moves
	iv.  readability
	v.   consistency of function names variables names etc
	vi.  comments & docstrings
	vii. removal of magic numbers



QUESTION: how is end game determined? (if pieces keep repeating)
	- the colour with the most pieces will win after a certain number of turns


Therrense todo:
- miniMax
	- disable moving square formation inside of range(2, 5)
	- 


